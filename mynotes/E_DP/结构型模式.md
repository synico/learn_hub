## 结构型模式

### Adapter
#### 类的适配器模式
使用一个具体类Adapter通过继承把源 (Adaptee) 适配到目标 (Target) 中。
* 同一个适配器仅能适配一个源类，而不能同时适配源类的子类。如需要适配源的子类，需要另外创建对应源类子类的适配器。
* 由于适配器类是源类的子类，因此可在适配器类中覆写源的方法。
#### 对象的适配器模式
通过委派关系把源 (Adaptee) 适配到目标 (Target) 中。
* 同一个适配器可以把源类和它的子类都适配到目标接口。
* 可通过实现源类的子类，在子类中覆写源类的方法。将源类的方法覆写，然后把源类的子类作为真正的源进行适配。

### Bridge
将抽象化与实现化脱耦，使得二者可以独立的变化。为同一个抽象化角色提供不同的实现。

### Composite
将对象组合成树形结构以表示部分与整体的层次结构。使得用户对单个对象和组合对象的使用具有一致性。

### Decorator
将更多的功能动态的附加到一个对象上。对功能扩展而言，装饰模式提供了一个灵活的，可以替代继承的选择。
* 需要动态的给一个对象增加功能，这些功能还可以再动态的撤销。
* 需要增加一些功能排列组合而产生的非常大量的功能，从而使继承关系变得不现实。
#### JDK中实例
* 所有java.io.InputStream，OutputStream，Reader和Writer的子类，它们的构造函数都接受同类型的实例作为参数。
* java.util.Collections，其中的checkedXXX()方法，synchronizedXXX()方法和unmodifiableXXX()方法。
* javax.servlet.http.HttpServletRequestWrapper和HttpServletResponseWrapper。

### Facade
外部与一个子系统的通信必须通过一个统一的门面对象进行。

### Flyweight
以共享的方式高效的支持大量的细粒度对象，其关键是区分内蕴状态和外蕴状态。

### Proxy
代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。
