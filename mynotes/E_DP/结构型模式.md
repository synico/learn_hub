## 结构型模式

### Adapter
适配器模式用来把一个已有对象接到不相匹配的接口上，核心是适配器和目标接口不一致的解决方案。
#### 类的适配器模式
使用一个具体类Adapter通过继承把源 (Adaptee) 适配到目标 (Target) 中。
* 同一个适配器仅能适配一个源类，而不能同时适配源类的子类。如需要适配源的子类，需要另外创建对应源类子类的适配器。
* 由于适配器类是源类的子类，因此可在适配器类中覆写源的方法。
#### 对象的适配器模式
通过委派关系把源 (Adaptee) 适配到目标 (Target) 中。
* 同一个适配器可以把源类和它的子类都适配到目标接口。
* 可通过实现源类的子类，在子类中覆写源类的方法。将源类的方法覆写，然后把源类的子类作为真正的源进行适配。
#### JDK中应用
* java.util.Arrays.asList()
* java.io.InputStreamReader(InputStream)返回Reader对象。
* java.io.OutputStreamWriter(OutputStream)返回Writer对象。

### Bridge
将抽象化与实现化脱耦，使得二者可以独立的变化。为同一个抽象化角色提供不同的实现。模式中的脱耦指在抽象化和实现化之间使用组合聚合关系而不是继承关系，从而使两者可以相对独立的变化。
#### JDK中应用
* AWT库中的Perr架构。
* JDBC驱动，通过DriverManager桥接不同类型数据库实现的驱动程序。

### Composite
将对象组合成树形结构以表示部分与整体的层次结构。使得用户对单个对象和组合对象的使用具有一致性。

### Decorator
将更多的功能动态的附加到一个对象上。对功能扩展而言，装饰模式提供了一个灵活的，可以替代继承的选择。
* 需要动态的给一个对象增加功能，这些功能还可以再动态的撤销。
* 需要增加一些功能排列组合而产生的非常大量的功能，从而使继承关系变得不现实。
#### 装饰模式与其他模式
##### 装饰模式与适配器模式
* 适配器模式的用意是改变目标对象的接口而不一定改变对象的行为性能。
* 装饰模式的用意是保持接口，并增加目标对象的性能功能。
##### 装饰模式与策略模式
* 装饰模式的实现要求Component类尽量的轻。
* 策略模式则要求抽象策略类尽量的重。
#### JDK中应用
* 所有java.io.InputStream，OutputStream，Reader和Writer的子类，它们的构造函数都接受同类型的实例作为参数。
* java.util.Collections，其中的checkedXXX()方法，synchronizedXXX()方法和unmodifiableXXX()方法。
* javax.servlet.http.HttpServletRequestWrapper和HttpServletResponseWrapper。

### Facade
外部与一个子系统的通信必须通过一个统一的门面对象进行。

### Flyweight
以共享的方式高效的支持大量的细粒度对象，其关键是区分内蕴状态和外蕴状态。

### Proxy
代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。
#### 代理模式与其他模式
##### 代理模式与适配器模式
* 适配器模式用意是改变被适配对象的接口。
* 策略模式并不改变被代理对象的接口。
##### 代理模式与装饰模式
* 代理模式用意是对被代理的对象施加控制。
* 装饰模式用意是增强被装饰对象的功能。
##### 代理模式与门面模式
门面模式可兼任代理模式的职责。
#### JDK中应用
* java.lang.reflect.Proxy
* java.rmi.\*中API
