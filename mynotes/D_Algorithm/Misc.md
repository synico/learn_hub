
#### 二维数组中的查找
题目: 在二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组到一个整数，判断数组中是否含有该整数。
<table>
<tr><td>1</td><td>2</td><td>8</td><td>9</td></tr>
<tr><td>2</td><td>4</td><td>9</td><td>12</td></tr>
<tr><td>4</td><td>7</td><td>10</td><td>13</td></tr>
<tr><td>6</td><td>8</td><td>11</td><td>15</td></tr>
</table>

思路: 可选取数组右上角或左下角的数字作为起始点。如果从左上角或右下角开始，无法从查找范围内删除查找所在行或列。
***

#### 字符串替换空格
题目: 实现一个函数，把字符串中的每个空格替换成"%20"。例如输入"We are happy."，则输出"We%20are%20happy."。

思路: 首先遍历一次字符串，计算出字符串中空格出现次数的总数。根据原字符串长度和需加入空格长度计算出新字符串长度。然后倒序复制输入字符串。所有字符串只复制一次，时间复杂度为O(N)。
***

### 链表
#### 从尾到头打印链表
题目: 输入一个链表的头结点，从尾到头反过来打印出每个节点的值。

思路: 典型的后进先出模式，可以用栈实现这种顺序。每经过一个结点的时候，把该结点放入栈中，当遍历完链表以后，再在栈中从栈顶开始遍历并输出值。

#### 在O(1)时间删除链表结点
题目: 给定单向链表的头结点和一个节点指针，定义一个函数在O(1)时间删除该结点。

思路: 常规做法需要获得被删除结点的前驱结点，所以需要遍历链表，但时间复杂度为O(N)。因为已有被删除结点指针，则可将其后续结点内容复制到目标删除结点覆盖目标结点的值，然后删除目标结点后续结点。则可实现时间复杂度O(1)。

#### 链表中的倒数第K个结点
题目: 输入一个链表，输出该链表中倒数第k个结点。限制为仅遍历链表一次。为符合大多数人的习惯，本题从1开始计数，即链表的尾结点是倒数第1个结点。例如一个链表有6个结点，从头结点开始它们的值依次是1，2，3，4，5，6。这个链表的倒数第3个结点是值为4的节点。

思路: 为了只遍历链表一次就找到倒数第k个结点，定义两个指针。第一个指针从链表头开始遍历向前走k-1步，第二个指针保持不动。从第k步开始，第二个指针也开始从链表头向前开始遍历。由于两个指针的距离始终保持在k-1，当第一个指针到达链表尾结点时，第二个结点正好走到倒数第k个结点。

#### 求链表的中间结点
题目: 求链表的中间结点。如链表中结点总数为奇数，返回中间结点；如果链表结点总数为偶数，返回中间两个结点的任意一个。

思路: 定义两个指针，同时从链表头结点出发，一个指针一次走一步，另一个指针一次走两步。当走的快的指针走到链表尾结点时，另一个走的慢的指针正好在链表中间。

#### 判断单向链表是否成环
题目: 判断一个单向链表是否形成环状结构。

思路: 定义两个指针，一个指针一次走一步，另一个指针走两步。如果两个指针重合，则链表是环形链表。并且环的长度等于快指针走过距离减去慢指针走过的距离。

#### 反转链表
#### 合并两个已排序的链表
#### 两个链表的第一个公共节点
