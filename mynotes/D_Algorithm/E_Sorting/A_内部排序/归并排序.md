## 归并排序 (merge sort)
***

### 2-路归并排序
#### 描述

#### 算法分析
* 归并排序是一种稳定的排序，最坏，最好，平均时间复杂度都为O(NlogN)。
* 归并排序在合并过程中因为用到线性附加列表，所以空间复杂度为O(logN)。

#### 实现
```
public static <AnyType extends Comparable<? extends AnyType>> void mergeSort(AnyType [] a) {
  AnyType [] tempArray = (AnyType []) new Comparable[a.length];
  mergeSort(a, tempArray, 0, a.length - 1);
}
private static <AnyType extends Comparable<? super AnyType>> void mergeSort(AnyType [] a, AnyType [] tempArray, int left, int right) {
  if(left < right) {
    int center = (left + right)/2;
    mergeSort(a, tempArray, left, center);
    mergeSort(a, tempArray, center + 1, right);
    merge(a, tempArray, left, center + 1, right);
  }
}
private static <AnyType extends Comparable<? super AnyType>> void merge(AnyType [] a, AnyType [] tempArray, int leftPos, int rightPos, int rightEnd) {
  int leftEnd = rightPos - 1;
  int tmpPos = leftPos;
  int numElements = rightEnd - leftPos + 1;
  //Main loop
  while(leftPos <= leftEnd && rightPos <= rightEnd) {
    if(a[leftPos] < a[rightEnd]) {
      tempArray[tmpPos++] = a[leftPos++];
    } else {
      tempArray[tmpPos++] = a[rightPos++];
    }
  }
  while(leftPos <= leftEnd) {//复制前半部分剩下的部分
    tempArray[tmpPos++] = a[leftPos++];
  }
  while(rightPos <= rightEnd) {//复制后半部分剩下的部分
    tempArray[tmpPos++] = a[rightPos++];
  }
  //Copy tempArray back
  for(int i = 0; i < numElements; i++, rightEnd--) {
    a[rightEnd] = tempArray[rightEnd];
  }
}
```
***
