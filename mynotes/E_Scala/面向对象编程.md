

### 方法
用关键字def声明
#### 定义
方法 (method) 指与实例绑定在一起的函数。
#### 方法签名包含
* 返回类型
* 方法名称
* 参数类型的列表

### 类
用关键字class声明

### 单例对象
用关键字object声明

### case类
用关键字case class声明
* case类会自动生成伴生对象及其apply方法，因为case类的实例通常就是通过调用apply方法创建出来的。
* case类为方便且简单的域类型提供了模式匹配和实例分解。

### 值类型
* 所有的值类型均为AnyVal的子类型，AnyVal是Any的两个子类型之一。
* 值类型的实例都是在寄存器或栈上，而不是堆上。
* 值类型没有构造器，实例总是通过字面量类创建。

### 构造器
#### 主构造器
* Scala将主构造器与零个或多个辅助构造器区分开。
* 主构造器是整个类体，构造器所需的参数都罗列在类名后。
* 调用主构造器不需要new关键字。
#### 辅助构造器
* 辅助构造器也被称为次级构造器，被命名为this。
* 辅助构造器的第一个表达式必须调用主构造器或其他辅助构造器。
* 编译器要求被调用的构造器在代码中先于当前构造器出现。

### 类字段
* 在主构造器函数参数的前面加上val或var关键字，该参数就成为类的一个字段。
* 对于case类，主构造函数参数前默认是val。
* 对于非case类，构造器参数列表参数省略val或val，则该参数不会成为类的字段，但该参数的值仍然在类体的作用范围内。

### 继承规则
* 一个抽象的基类或trait，只被下一层的具体的类继承，包括case类。
* 具体类的子类永远不会再次被继承。除了类中混入了定义于trait中的其他行为，或用于支持自动化单元测试的类。
* 当使用子类继承可能是正确的做法时，考虑将行为分离到trait中，然后在类里混入这些trait。
* 切勿将逻辑状态跨越父类和子类。

### 特征 (trait)
* 待声明的类未扩展其他类，只是混入了一些trait，则必须使用extends关键字，并将其用于第一个trait，而在其他的trait之前使用with关键字。
* 实例化某一类型时混入trait，需在所有trait前使用with关键字。
* trait中方法调用了super对象中的另一方法，但是被调用的这个方法在该trait的父类中尚未定义具体的实现方法，则需要在这个trait中的方法前加上abstract关键字。
***

## 类型系统
### 参数化类型
变异标记只在类型声明中的类型参数里才有意义，对参数化的方法没有意义，因为该标记影响的是子类继承行为，而方法没有子类。
#### 参数多态
在集合List[A]中使用任何类型作为类型A，这种特性被称为参数多态。在方法List的通用实现中，允许使用任何类型的实例作为List的元素。
#### 变异标记
* `+A`表示协变 (covariance)
* `-A`表示逆变 (contravariance)
* `A`表示非转化 (invariant)
#### 协类型和逆类型
* List[+A]中A之前的+表示如果B是A的子类，则List[B]也是List[A]的子类型，称为协类型。
* List[-A]中A之前的-表示如果B是A的子类型，则List[B]是List[A]的父类型，称为逆类型。
***

### 类型边界
同时定义类型边界的上下限，边界的下限必须出现在上限之前。
#### 类型边界上限
#### 类型边界下限
***

### 变异标记和类型边界
* 类型边界对参数化类型所允许采用的类型做了限制。
`如T <: AnyRef约束T必须为AnyRef的子类型。`
* 变异标记表示参数化类型的子类型实例是否可以替换父类实例。
`如List[+T]是协变的，所以List[T]是List[AnyRef]的子类型`
