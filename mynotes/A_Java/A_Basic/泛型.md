# 泛型

#### 泛型代码和虚拟机
1. 由于类型擦除（erased），虚拟机中没有泛型，即编译生成的字节码不包含泛型信息。
2. 所有的类型参数都用它们的限定类型替换，如果没有用Object替换。
3. 虚拟机生成桥方法（bridge method）保持多态。
4. 为保持类型安全性，必要时插入强制类型转换。

#### 约束与局限性
1. 不能用基本类型实例化类型参数。即没有List<int>，只有List<Integer>。
2. 运行时类型查询只适用于原始类型。如对List<String>调用getClass()返回结果为List。或(a instanceof List<String>)，参照类型List的泛型<String>被忽略，同样a的泛型信息也被忽略擦除。
3. 不能抛出也不能捕获泛型类实例。但是在异常声明中可以使用类型变量。  
`catch(T e) 不合法`  
`throws T 合法`
4. 参数化类型的数组不合法。
5. 不能实例化类型变量。
6. 泛型类的静态上下文中类型变量无效。禁止使用带有类型变量的静态域或方法。
7. 注意类型擦除后的冲突。

#### 泛型类型的继承规则
比如`List<List>`和`List<ArrayList>`不存在继承关系。不能互相直接转型（Class Cast）。
