# JVM运行时数据区

#### 1. 虚拟机栈（JVM Stack）
*线程私有区域*，生命周期与线程相同。包含以下四个部分：  
1) 局部变量表：是一组变量值存储空间。用于存放方法参数和方法中定义的局部变量。局部变量表的空间在编译时完成分配。  
2) 操作数栈  
3) 动态链接  
4) 方法返回地址  

如果线程请求的栈深大于虚拟机所允许的深度，将抛出StackOverflowError异常（在函数递归调用时容易出现该异常）。如果虚拟机栈允许动态扩展，但在扩展时如无法申请足够的内存，则会跑出OutOfMemory异常。

#### 2. 程序计数器（Program Counter Register）
*线程私有区域*。当前线程执行字节码的行号指示器。

#### 3. 本地方法区（Native Method Stack）
*线程私有区域*。

#### 4. 堆（Heap）
*所有线程共享的一块内存区域*，在虚拟机启动时创建。该区域是用来存放所有对象实例和数组本身（数组引用存放在栈）。堆的大小由虚拟机启动时的参数-Xmx和-Xms控制。

#### 5. 方法区（Method Area）
*所有线程共享的一块内存区域*，用于存放被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。在JVM规范里方法区被描述为堆的一个逻辑部分，但它却有一个别名叫做非堆（Non-Heap）。

运行时常量池（Runtime Constant Pool）方法区的一部分。  
常量池（Constant Pool），用于存放编译期生成的各种字面常量和符号引用，这部分信息将在类加载后进入方法区的运行时常量池中存放。

![jvm](images/jvm.png)

程序计数器，虚拟机栈，本地方法栈3个区域中对象生命周期与调用线程相同。

#### 判断对象存活算法
1. 引用计数法  
给对象添加一个引用计数器，每当有一个地方引用该对象时，计数器值就加1；当引用失效时，计数器值就减1。任何时刻计数器值为0，表示该对象不可能再被使用。
2. 可达性分析算法  
通过一系列的称为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有引用链时，则表示该对象是不可用的。

#### GC Roots对象
1. 虚拟机栈（栈帧中的本地变量表）
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中JNI（即Native方法）引用的对象
