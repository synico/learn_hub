# 多线程基本概念

#### 1. 进程和线程的区别
进程拥有一套独立的变量，而进程则会共享变量数据。

#### 2. 创建线程的两种方式
1) 继承Thread类并覆写其run方法。  
2) 实现Runnable接口并实现run方法，再将实现Runnable接口的对象传给Thread的构造函数。

#### 3. 并发的正确执行，需要保证以下三点：
1) 可见性  
2) 原子性  
3) 有序性

# Thread

#### 1. 线程状态
1) New（新生）
使用new操作符创建一个新线程时，该线程还没开始运行。  
2) Runnable（可运行）
调用Thread.start方法时，线程处于Runnable状态，不代表线程正在运行。  
3) Blocked（被阻塞）
当一个线程试图获取一个内部的对象锁（不是java.util.concurrent库中的锁），而该锁被其他线程持有，则该线程进入阻塞状态。  
4) Waiting（等待）
当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。如调用Object.wait()或Thread.join()，或是等待java.util.concurrent库中的Lock或Condition时，线程进入等待状态。  
5) Timed waiting（计时等待）
当调用带有超时参数的方法，调用的线程进入计时等待状态。这种状态将一直保持到超时期满或接收到适当的通知。如调用Thread.sleep(n)，Object.wait(n)，Thread.join(n)，Lock.tryLock(n)和Condition.await(n)时。  
6) Terminated（被终止）
run方法正常退出而正常死亡，如遇到代码return;。或遇到未捕获的异常而意外死亡。

#### 2. Thread.interrupt方法
1) interrupt方法可以请求终止线程，但不保证线程一定终端而不继续运行。  
2) 如果线程被阻塞(处于阻塞，等待，计时等待状态)时调用interrupt方法会导致终止请求失败，并抛出InterruptedException异常。

# java.util.concurrent Overview

#### 执行程序

#### 1. 接口  
1) Executor是一个简单的标准化接口，用于定义类似于线程的自定义子系统，包括线程池，异步IO和轻量级任务框架。根据所使用的具体Executor类的不同，可能在新建的线程中，现有运行任务的线程，或调用execute方法的线程，并且可能顺序执行或并发执行。  
2) ExecutorService提供了多个完整的异步任务执行框架。管理任务的queuing和scheduling，并允许可控的关闭。还提供了安排异步执行的方法，可执行由Callable表示的任何函数，结果类似Runnable。  
3) ScheduledExecutorService子接口及相关的接口增加了对延迟执行和定时执行的支持。  
4) Future返回函数的结果，允许确定执行是否完成，并提供取消执行的方法。  
5) RunnableFuture是拥有run方法的Future，run方法执行时设置其结果。

#### 2. 实现
1) 类ThreadPoolExecutor和ScheduledThreadPoolExecutor提供可调整的，灵活的线程池实现。
2) Executors提供大多数Executor的常见类型和配置的工厂方法，及使用它的工具方法。
3) FutureTask提供了Future的常见可扩展实现。
4) ExecutorCompletionService

#### 队列
ConcurrentLinkedQueue提供了高效，可伸缩，线程安全的非阻塞FIFO队列。

#### 同步器
四个类可协助实现常见的专用同步器。  
1) Semaphore，计数信号量。概念上讲，信号量维护了一个许可集。对许可的号码进行计数，并采取相应的行动。  
2) CountDownLatch，在保持给定数目的信号，事件或条件前阻塞执行。  
3) CyclicBarrier是一个可重置的多路同步点。  
4) Exchanger允许两个线程在collection点交换对象，在多流水线设计中有用。  

#### 并发Collection

#### 内存一致属性（happen-before）
JSL中定义了内存操作（如共享变量的读写）的happen-before关系。只有写入操作happen-before读取操作时，才能保证一个线程写入的结果对另外一个线程的读取时可见的。synchronzied和volatile关键字构造happen-before关系，Thread.start()和Thread.join()方法形成happen-before关系。  
1) 线程中每个操作都happen-before该线程中此操作之后被调用的操作。  
2) 对一个监视器的解锁动作（synchronzied阻塞或方法退出）happen-before对同一个监视器的所有加锁动作（synchronzied阻塞或方法进入）。锁具有传递性，并可嵌套加锁。同样happen-before也具有传递性。  
3) 写入volatile变量happen-before对这个变量的读取。对volatile变量的读写和进入退出监视器具有相似的内存一致性效果，但不需要互斥锁。  
4) 对线程start方法的调用happen-before同一线程所有操作的执行。  
5) 一个线程的所有操作happen-before其他成功调用了join的线程。比如启动了A，B两个线程，其中对A线程调用了join方法。则A线程会等待B线程的所有操作执行完毕后再执行。  

java.util.concurrent中所有类包括其子包中类的方法扩展了更高级别的同步。  
1) 线程中将一个对象加入任何并发容器中的操作happen-before其他线程访问或移除同一对象的操作。  
2) 线程中向Executor提交Runnable之前的操作happen-before其开始执行。对于向ExecutorService提交Callable也是类似的。  
3) 异步计算（比如通过Future）所执行的操作happen-before其他线程通过Future.get()获取结果之后的操作。  
4) 对同一对象“释放”同步方法（如Lock.unlock，Semaphore.release和CountDownLatch.countDown方法）之前的操作happen-before另一线程对该对象的“获取”操作（如Lock.lock，Semaphore.acquire，Condition.await和CountDownLatch.await方法）。  
5) 通过Exchanger成功交换对象的每个线程对，每个线程中exchange方法之前的操作happen-before另一线程中对应的exchange方法之后的操作。  
