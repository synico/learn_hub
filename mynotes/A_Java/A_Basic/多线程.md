# 多线程基本概念

#### 进程和线程的区别
进程拥有一套独立的变量，而进程则会共享变量数据。

#### 创建线程的两种方式
1. 继承Thread类并覆写其run方法。
2. 实现Runnable接口并实现run方法，再将实现Runnable接口的对象传给Thread的构造函数。

#### 并发的正确执行，需要保证以下三点：
1. 可见性（volatile）
2. 原子性（锁和CAS）
3. 有序性（happen-before原则）

# Thread

#### 线程状态
1. New（新生）  
使用new操作符创建一个新线程时，该线程还没开始运行。
2. Runnable（可运行）  
调用Thread.start方法时，线程处于Runnable状态，不代表线程正在运行。
3. Blocked（被阻塞）  
当一个线程试图获取一个内部的对象锁（不是java.util.concurrent库中的锁），而该锁被其他线程持有，则该线程进入阻塞状态。
4. Waiting（等待）  
当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。如调用Object.wait()或Thread.join()，或是等待java.util.concurrent库中的Lock或Condition时，线程进入等待状态。
5. Timed waiting（计时等待）  
当调用带有超时参数的方法，调用的线程进入计时等待状态。这种状态将一直保持到超时期满或接收到适当的通知。如调用Thread.sleep(n)，Object.wait(n)，Thread.join(n)，Lock.tryLock(n)和Condition.await(n)时。
6. Terminated（被终止）  
run方法正常退出而正常死亡，如遇到代码return;。或遇到未捕获的异常而意外死亡。

#### Thread.interrupt方法
1. interrupt方法可以请求终止线程，但不保证线程一定终端而不继续运行。
2. 如果线程被阻塞(处于阻塞，等待，计时等待状态)时调用interrupt方法会导致终止请求失败，并抛出InterruptedException异常。

#### Thread.start方法
1. 不要调用Thread类或Runnable对象的run方法。直接调用run方法，只会执行同一个线程中的任务，而不会启动新线程。
2. 调用Thread.start方法将调用JVM本地方法创建一个新的线程执行run方法。

#### Thread.sleep方法
调用sleep方法使线程停止继续运行预定的时间，在此期间仍拥有锁。

#### Object.wait方法
调用对象的wait方法，导致当前线程放弃当前持有的锁，并将线程加入对象的等待集中。直到线程从等待集中移出。

#### Runnable和Callable
1. Runnable的run方法不能有返回值，也无法抛出异常（异常必须在run方法内处理）。
2. Callable的call方法可以有返回值（含有运行结果的Future对象），允许抛出异常。

# java.util.concurrent Overview

#### 执行程序接口
1. Executor是一个简单的标准化接口，用于定义类似于线程的自定义子系统，包括线程池，异步IO和轻量级任务框架。根据所使用的具体Executor类的不同，可能在新建的线程中，现有运行任务的线程，或调用execute方法的线程，并且可能顺序执行或并发执行。
2. ExecutorService提供了多个完整的异步任务执行框架。管理任务的queuing和scheduling，并允许可控的关闭。还提供了安排异步执行的方法，可执行由Callable表示的任何函数，结果类似Runnable。
3. ScheduledExecutorService子接口及相关的接口增加了对延迟执行和定时执行的支持。
4. Future返回函数的结果，允许确定执行是否完成，并提供取消执行的方法。
5. RunnableFuture是拥有run方法的Future，run方法执行时设置其结果。

#### 执行程序实现
1. 类ThreadPoolExecutor和ScheduledThreadPoolExecutor提供可调整的，灵活的线程池实现。
2. Executors提供大多数Executor的常见类型和配置的工厂方法，及使用它的工具方法。
3. FutureTask提供了Future的常见可扩展实现。
4. ExecutorCompletionService

# 内存一致属性（happen-before）

JSL中定义了内存操作（如共享变量的读写）的happen-before关系。只有写入操作happen-before读取操作时，才能保证一个线程写入的结果对另外一个线程的读取时可见的。synchronzied和volatile关键字构造happen-before关系，Thread.start()和Thread.join()方法形成happen-before关系。
1. 线程中每个操作都happen-before该线程中此操作之后被调用的操作。
2. 对一个监视器的解锁动作（synchronzied阻塞或方法退出）happen-before对同一个监视器的所有加锁动作（synchronzied阻塞或方法进入）。锁具有传递性，并可嵌套加锁。同样happen-before也具有传递性。
3. 写入volatile变量happen-before对这个变量的读取。对volatile变量的读写和进入退出监视器具有相似的内存一致性效果，但不需要互斥锁。
4. 对线程start方法的调用happen-before同一线程所有操作的执行。
5. 一个线程的所有操作happen-before其他成功调用了join的线程。比如启动了A，B两个线程，其中对A线程调用了join方法。则A线程会等待B线程的所有操作执行完毕后再执行。

java.util.concurrent中所有类包括其子包中类的方法扩展了更高级别的同步。
1. 线程中将一个对象加入任何并发容器中的操作happen-before其他线程访问或移除同一对象的操作。
2. 线程中向Executor提交Runnable之前的操作happen-before其开始执行。对于向ExecutorService提交Callable也是类似的。
3. 异步计算（比如通过Future）所执行的操作happen-before其他线程通过Future.get()获取结果之后的操作。
4. 对同一对象“释放”同步方法（如Lock.unlock，Semaphore.release和CountDownLatch.countDown方法）之前的操作happen-before另一线程对该对象的“获取”操作（如Lock.lock，Semaphore.acquire，Condition.await和CountDownLatch.await方法）。
5. 通过Exchanger成功交换对象的每个线程对，每个线程中exchange方法之前的操作happen-before另一线程中对应的exchange方法之后的操作。
