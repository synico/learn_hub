# JVM运行时数据区

#### 虚拟机栈（JVM Stack）
*线程私有区域*，生命周期与线程相同。包含以下四个部分：
1. 局部变量表：是一组变量值存储空间。用于存放方法参数和方法中定义的局部变量。局部变量表的空间在编译时完成分配。
2. 操作数栈
3. 动态链接
4. 方法返回地址

如果线程请求的栈深大于虚拟机所允许的深度，将抛出StackOverflowError异常（在函数递归调用时容易出现该异常）。如果虚拟机栈允许动态扩展，但在扩展时如无法申请足够的内存，则会跑出OutOfMemory异常。

#### 程序计数器（Program Counter Register）
*线程私有区域*。当前线程执行字节码的行号指示器。

#### 本地方法区（Native Method Stack）
*线程私有区域*。

#### 堆（Heap）
*所有线程共享的一块内存区域*，在虚拟机启动时创建。该区域是用来存放所有对象实例和数组本身（数组引用存放在栈）。堆的大小由虚拟机启动时的参数-Xmx和-Xms控制。

#### 方法区（Method Area）
*所有线程共享的一块内存区域*，用于存放被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。在JVM规范里方法区被描述为堆的一个逻辑部分，但它却有一个别名叫做非堆（Non-Heap）。
1. 通过JDK动态代理或CGLib这类字节码增强技术，生成的动态Class存放在方法区。
2. JVM上动态语言，如Groovy创建的类也存放在方法区。

运行时常量池（Runtime Constant Pool）方法区的一部分。
常量池（Constant Pool），用于存放编译期生成的各种字面常量和符号引用，这部分信息将在类加载后进入方法区的运行时常量池中存放。

![jvm](images/jvm.png)

程序计数器，虚拟机栈，本地方法栈3个区域中对象生命周期与调用线程相同。

# 堆（Heap）的空间划分

##### 堆主要被划分为三个区域
1. 新生代（Young Generation）
2. 老年代（Old Generation）
3. 永久代（Permanent Generation）

##### 对象的内存分配
1. 对象优先分配在新生代的Eden区，如果启动了本地线程分配缓冲，将按线程优先在TLAB（Thread Local Allocation Buffer）上分配。
2. 大对象直接直接进入老年代。大对象指的是需要大量连续内存空间的Java对象，例如很长的字符串和大数组。

#### 新生代（Young Generation）的空间划分
新生代被划分为三个区域，新生代的可用空间是Eden区空间和一个Survivor区空间之和。
1. Eden：主要存放新生对象。
2. From Survivor
3. To Survivor
两个Survivor区存放每次Minor GC后存活的对象。当Eden区没有足够空间分配时，JVM将发起一次Minor GC。

# 垃圾回收

#### 判断对象存活算法
1. 引用计数法
给对象添加一个引用计数器，每当有一个地方引用该对象时，计数器值就加1；当引用失效时，计数器值就减1。任何时刻计数器值为0，表示该对象不可能再被使用。主要缺陷是此算法很难解决对象之间相互循环引用的问题。
2. 可达性分析算法
通过一系列的称为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有引用链时，则表示该对象是不可用的。

#### GC Roots对象
1. 虚拟机栈（栈帧中的本地变量表）
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中JNI（即Native方法）引用的对象

#### 四种引用类型
1. 强引用（StrongReference）  
只要强引用存在，GC永远不会回收掉被引用的对象。
2. 软引用（SoftReference）  
在系统将要发生OOM之前，将会把这些对象放入回收范围内进行第二次回收。如果这次回收还没有足够内存，才会抛出OOM异常。在内存敏感的Cache系统中使用SoftReference是比较合适的场景。
3. 弱引用（WeakReference）  
被弱引用关联的对象只能生存到下一次GC发生之前。当GC工作时，无论当前内存是否足够都会回收掉只被WeakReference关联的对象。
4. 虚引用（PhantomReference）  
一个对象是否有PhantomReference的存在，完全不会对其生存时间构成影响，也无法通过PhantomReference取得一个对象实力。为一个对象设置PhantomReference关联的唯一目的就是在这个对象被GC回收时收到一个通知。

#### 垃圾收集算法
1. 标记-清除算法（Mark-Sweep）
分标记和清除两个阶段，首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。但是标记和清除效率都不高，其次清除后会产生大量不连续的内存碎片。
2. 复制算法（Copying）
将可用内存按容量划分为大小相等两块，每次只使用其中一块。当一块的空间用完了，就将还存活的对象复制到另一块内存中，然后把已使用过的内存一次清理掉。
3. 标记-整理算法（Mark-Compact）
和标记清除算法类似，但是标记完成后不是直接对可回收对象进行清除，而是让所有存活对象都向一端移动，然后直接清理掉边界以外的内存。
4. 分代收集算法（Generational Collecton）
新生代采用复制算法
老年代采用标记清除算法或标记整理算法

#### 垃圾收集器
1. Serial/Serial Old
2. ParNew
3. Parallel scavenge/Old
4. CMS（Concurrent Mark Sweep）
5. G1（Garbage First）
