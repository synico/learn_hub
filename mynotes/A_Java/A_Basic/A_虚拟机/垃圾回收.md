## 垃圾回收
***

### 判断对象存活算法
#### 引用计数法
给对象添加一个引用计数器，每当有一个地方引用该对象时，计数器值就加1；当引用失效时，计数器值就减1。任何时刻计数器值为0，表示该对象不可能再被使用。主要缺陷是此算法很难解决对象之间相互循环引用的问题。
#### 可达性分析算法
通过一系列的称为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有引用链时，则表示该对象是不可用的。
***

### GC Roots
可作为GC Roots的对象
* 虚拟机栈 (栈帧中局部变量表) 中引用的对象。
* 方法区中类静态属性的引用。
* 方法区中常量引用的对象。
* 本地方法栈中JNI (即本地方法) 引用的对象。
***

### 垃圾回收算法
#### 标记-清除算法 (Mark-Sweep)
分标记和清除两个阶段，首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。但是标记和清除效率都不高，其次清除后会产生大量不连续的内存碎片。
#### 复制算法 (Copying)
将可用内存按容量划分为大小相等两块，每次只使用其中一块。当一块的空间用完了，就将还存活的对象复制到另一块内存中，然后把已使用过的内存一次清理掉。
#### 标记-整理算法 (Mark-Compact)
和标记清除算法类似，但是标记完成后不是直接对可回收对象进行清除，而是让所有存活对象都向一端移动，然后直接清理掉边界以外的内存。
#### 分代收集算法 (Generational Collecton)
新生代采用复制算法，老年代采用标记清除算法或标记整理算法。
***

### 垃圾回收器
#### Serial/Serial Old
#### ParNew
#### Parallel scavenge/Old
#### CMS（Concurrent Mark Sweep）
#### G1（Garbage First）
***

### 四种引用类型
#### 强引用 (StrongReference)
普通情况下定义对象时的引用。只要强引用存在，GC永远不会回收掉被引用的对象。
#### 软引用 (java.lang.ref.SoftReference)
在系统将要发生OOM之前，将会把这些对象放入回收范围内进行第二次回收。如果这次回收还没有足够内存，才会抛出OOM异常。在内存敏感的Cache系统中使用SoftReference是比较合适的场景。
#### 弱引用 (java.lang.ref.WeakReference)
被弱引用关联的对象只能生存到下一次GC发生之前。当GC工作时，无论当前内存是否足够都会回收掉只被WeakReference关联的对象。
#### 虚引用 (java.lang.ref.PhantomReference)
一个对象是否有PhantomReference的存在，完全不会对其生存时间构成影响，也无法通过PhantomReference取得一个对象实例。为一个对象设置PhantomReference关联的唯一目的就是在这个对象被GC回收时收到一个通知。
