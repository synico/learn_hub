## 垃圾回收

### 判断对象存活算法
#### 引用计数法
给对象添加一个引用计数器，每当有一个地方引用该对象时，计数器值就加1；当引用失效时，计数器值就减1。任何时刻计数器值为0，表示该对象不可能再被使用。主要缺陷是此算法很难解决对象之间相互循环引用的问题。
#### 可达性分析算法
通过一系列的称为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有引用链时，则表示该对象是不可用的。
***

### GC Roots
可作为GC Roots的对象
* 虚拟机栈 (栈帧中局部变量表) 中引用的对象。
* 方法区中类静态属性的引用。
* 方法区中常量引用的对象。
* 本地方法栈中JNI (即本地方法) 引用的对象。
***

### 垃圾回收算法
#### 标记-清除算法 (Mark-Sweep)
分标记和清除两个阶段，首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。但是标记和清除效率都不高，其次清除后会产生大量不连续的内存碎片。
#### 复制算法 (Copying)
将可用内存按容量划分为大小相等两块，每次只使用其中一块。当一块的空间用完了，就将还存活的对象复制到另一块内存中，然后把已使用过的内存一次清理掉。
#### 标记-整理算法 (Mark-Compact)
和标记清除算法类似，但是标记完成后不是直接对可回收对象进行清除，而是让所有存活对象都向一端移动，然后直接清理掉边界以外的内存。
#### 分代收集算法 (Generational Collecton)
新生代采用复制算法，老年代采用标记清除算法或标记整理算法。
***

### 垃圾回收器
* 并行 (Parallel):指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
* 并发 (Concurrent):指用户线程与垃圾收集线程同时执行，但不一定是并行的，可能会交替执行，用户程序在继续执行，而垃圾收集程序运行在另一个CPU上。
#### Serial
* 单线程收集器，采用复制算法
* 新生代收集器
* 因其简单而高效的特点，适用于用户的桌面应用上
#### Serial Old
* 单线程收集器，采用标记整理算法
* 老年代收集器
* 在Server模式下，可与Parallel Scavenge收集器搭配使用。另外可作为CMS发生Concurrent Mode Failure时的后备预案
#### ParNew
* 多线程收集器，Serial收集器的多线程版本，采用复制算法
* 新生代垃圾收集器
* 当使用CMS作为老年代垃圾收集器，ParNew为默认新生代收集器
* 可使用-XX +UseParNewGC选项来制定垃圾收集器
#### Parallel Scavenge
* 并行的多线程收集器
* 新生代收集器
* 目标达到一个可控制的吞吐量 (吞吐量 = 运行用户代码时间/(运行用户代码时间+垃圾收集时间))
#### Parallel Old
* 多线程收集器
* 老年代收集器，Parallel Scavenge的老年代版本
* 标记-整理算法
#### CMS (Concurrent Mark Sweep)
多线程，以获取最短回收停顿时间为目标的收集器
##### 初始标记 (initial mark)
仍需要停顿，仅标记GC Roots能直接关联到的对象，速度很快。
##### 并发标记 (concurrent mark)
进行GC Roots Tracing的过程。
##### 重新标记 (remark)
修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段停顿时间比初始标记阶段稍长，但比并发标记阶段时间短。
##### 并发清除 (concurrent sweep)
此过程与用户线程一起工作，无停顿。
##### 缺点
* 对CPU资源敏感，并发回收时占用较大CPU资源。
* 无法处理浮动垃圾，可能出现Concurrent Mode Failure而导致另一次Full GC的产生。
* 因为采用并发清理算法，会出现大量空间碎片。
#### G1 (Garbage First)
使用G1收集器时，Java堆的内存布局就与其他收集器有很大区别，它将这个堆划分为多个大小相等的独立区域 (Region) ，虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的，它们都是一部分Region (不需要连续) 的集合。
***

### 安全点和安全区域
#### 安全点 (Safepoint)
采用主动式中断，各个线程执行时主动轮询中断标识，如发现中断标识为真时就自己中断挂起。
#### 安全区域 (Safe Region)
当线程处于sleep或blocked状态，即未分配CPU时间时，线程无法响应JVM进行GC的中断请求，需要安全区域来解决。安全区域是指一段代码片段中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。当线程执行到安全区域时，首先标识自己进入安全区域。在线程要离开安全区域时，线程需要检查JVM是否完成了根节点枚举或整个GC过程，如果完成，则线程继续执行。否则线程必须等待直到收到可以离开安全区域的信号为止。
***

### 四种引用类型
#### 强引用 (StrongReference)
普通情况下定义对象时的引用。只要强引用存在，GC永远不会回收掉被引用的对象。
#### 软引用 (java.lang.ref.SoftReference)
在系统将要发生OOM之前，将会把这些对象放入回收范围内进行第二次回收。如果这次回收还没有足够内存，才会抛出OOM异常。在内存敏感的Cache系统中使用SoftReference是比较合适的场景。
#### 弱引用 (java.lang.ref.WeakReference)
被弱引用关联的对象只能生存到下一次GC发生之前。当GC工作时，无论当前内存是否足够都会回收掉只被WeakReference关联的对象。
#### 虚引用 (java.lang.ref.PhantomReference)
一个对象是否有PhantomReference的存在，完全不会对其生存时间构成影响，也无法通过PhantomReference取得一个对象实例。为一个对象设置PhantomReference关联的唯一目的就是在这个对象被GC回收时收到一个通知。
