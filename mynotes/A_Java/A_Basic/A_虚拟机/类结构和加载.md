
### Class类文件结构
#### 常量池
常量池包括字面量 (Literal) 和符号引用 (Symbolic References)。
##### 字面量
比较接近语言层面的常量概念，如文本字符串，声明为final的常量值等。
##### 符号引用
Java代码在编译的时候，并不像C和C++那样有连接步骤，而是虚拟机加载Class文件时进行动态连接。即在Class文件中不保存各个方法，字段的最终内存布局信息。因此这些方法字段的符号引用不经过运行期转换则无法得到对象真正的内存入口地址，也就无法被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析，翻译到具体内存地址。
符号引用包括以下三类常量
* 类和接口的全限定名。
* 字段的名称和描述符。
* 方法的名称和描述符。

#### 方法表
##### 方法重载
重载 (overload) 一个方法，除了要与原方法具有相同的简单名称外，还需要拥有一个与原方法不同的特征签名。
##### 特征签名
特征签名是一个方法中各个参数在常量池中的字段符号引用的集合，而方法返回值不在特征签名中。因此无法根据返回值对一个已有方法进行重载。但在Class文件结构中，特征签名的范围可以更大些，只要描述符不是完全一致的两个方法可以共存。即如果两个方法有相同的名称和特征签名，但返回值不同，那么也可以合法共存于同一个Class文件中。
***

### 对象的存储结构
* 对象头 (Header)
* 实例数据 (Instance Data)
* 对齐填充 (Padding)

#### 对象头结构
##### Mark World结构
存储对象自身的运行时数据。
* 哈希码
* GC分代年龄
* 锁状态标志
* 线程持有的锁
* 偏向线程ID
* 偏向时间戳
##### Mark World存储内容
运行期间Mark Word里存储的值会随着锁标志位的变化而变化。

锁状态|25bit|4bit|1bit (是否偏向锁) |25bit (锁标志位)
:-|:-|:-|:-|:-
无锁状态|对象的HashCode|对象分代年龄|0|01
偏向锁|线程ID和Epoch|对象分代年龄|1|01
轻量级锁|指向栈中锁记录的指针|||00
重量级锁|指向重量级锁的指针|||10
GC标记|空|||11

##### 类型指针
对象指向它的类元数据的指针，JVM通过这个指针来确定这个对象类型 (即哪个类的实例) 。但不是所有JVM都必须在对象数据上保留类型指针，即对象的元数据不一定要通过对象本身。
***

### 类加载过程
虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可被虚拟机使用的Java类型，这就是虚拟机的类加载机制。
JVM加载类分三步
* 加载
* 连接
* 初始化

#### 加载
##### 非数组类
* 通过一个类的全限定名称获取定义此类的二进制字节流。
* 将这个字节流代表的静态存储结构转化为方法区的运行时数据结构。
* 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类各种数据访问的入口。

##### 数组类
数组类本身不通过类加载器创建，而由虚拟机直接创建。但数组类的元素类型 (Element Type) 最终通过类的加载器加载。
* 如果数组类的元素类型是引用类型，则采用非数组类加载过程去加载这个元素类型，数组将在加载该组件类型的类加载器的类名称空间上被标识。
* 如果数组的元素类型不是引用类型，虚拟机将把数据标记与引导类加载器关联。

##### Class对象
对Hotspot虚拟机而言，Class对象比较特殊，它虽然是对象，但却存放在方法区。这个对象将作为程序访问方法区中的这些类型数据的外部入口。

#### 验证 (类连接过程)
连接阶段的第一步，用来确保Class文件的字节流中包含的信息符合当前虚拟机要求，不会危害虚拟机的安全。
* 文件格式验证。
* 元数据验证。进行语义分析，以保证满足Java语言规范。
* 字节码验证。
* 符号引用验证。确保解析动作能正常执行。发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将发生在连接的第三个阶段解析中。

#### 准备 (类连接过程)
为类变量分配内存并设置类变量初始值的阶段。这些变量所使用的内存都将在方法区中进行分配。
* 此时进行变量分配的仅包含类变量 (被static修饰的变量) 而不包含实例变量。实例变量将在对象实例化时在堆上分配空间。
* 初始值指的是变量的零值。而变量的赋值将发生在初始化阶段。

#### 解析 (类连接过程)
虚拟机将常量池中符号引用替换为直接引用的过程。
* 符号引用，以一组符号来描述所引用的目标。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。
* 直接引用，直接引用可以是直接指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。直接引用和虚拟机实现的内存布局相关。如果有了直接引用，那引用的目标必定已经存在内存中。

#### 初始化
类加载过程的最后一步。真正开始执行类中定义的Java程序代码，也是执行类构造器```<Clinit>()```方法的过程。``` <Clinit>()```方法是编译器自动收集类中的所有类变量的赋值动作和静态语句块 (static{}块) 中的语句合并产生。编译器的收集顺序由语句在源文件中出现的顺序所决定，静态块中只能访问到定义静态块之前的变量，定义在它之后的变量，在前面的静态块中可以赋值，但不能访问。
##### 主动引用规则
JVM对类进行初始化 (主动引用) 的四种情况
* 使用new关键字实例化对象时；读取 (get) 或设置 (set) 一个类 (直接定义这个变量的类才会被初始化) 的静态 (static) 变量时 (使用static final修饰的，已在编译器被放入常量池的变量除外) ；以及调用类的静态方法时。
* 通过java.lang.reflect包的方法对类进行反射调用时，如发现类未被初始化，则先触发其初始化。
* 当初始化类时，如发现其父类还未初始化，先触发其父类的初始化。
* 当JVM启动时需要为JVM指定一个要执行的主类，JVM会首先初始化这个主类。
